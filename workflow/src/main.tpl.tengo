// STAR preprocessing workflow
//
// Minimum Viable Block:
//
// Expected arguments:
//  - ref: Ref               	- a reference to the fastq file
//  - species: string        	- species
//  - libraryType: string	 	- single-end or paired-end
//
// Outputs:
//	- progress: handle		 	- analysis log
//
// Exports:
//	- rawCounts: p-frame 		- raw count matrix p-frame
//
// Extended version:
//
// Expected arguments:
//  - ref: Ref               	- a reference to the fastq file
//  - species: string        	- species
//  - libraryType: string	 	- single-end or paired-end
//
// Outputs:
//	- progress: handle		 	- analysis log
//	- pcaComponents: p-frame 	- PCA p-frame
//	- sampleDistances: p-frame 	- Hierarchical clustering output distances
//	- multiQC: handle 			- multiQC report
//
// Exports:
//	- rawCounts: p-frame 		- raw count matrix p-frame
//	- normCounts: p-frame		- normalized count matrix p-frame
//

wf := import("@platforma-sdk/workflow-tengo:workflow")

ll := import("@platforma-sdk/workflow-tengo:ll")
xsv := import("@platforma-sdk/workflow-tengo:pframes.xsv")
exec := import("@platforma-sdk/workflow-tengo:exec")
file := import("@platforma-sdk/workflow-tengo:file")
pSpec := import("@platforma-sdk/workflow-tengo:pframes.spec")
render := import("@platforma-sdk/workflow-tengo:render")
assets := import("@platforma-sdk/workflow-tengo:assets")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
llPFrames := import("@platforma-sdk/workflow-tengo:pframes.ll")

genomes := import(":genomes")
pfCountsConv := import(":pf-counts-conv")
pfPcaConv := import(":pf-pca-conv")
hcPfconvParams := import(":pf-hcparams-conv")
pfNormCountsConv := import(":pf-norm-counts-conv")

starAlignmentTpl := assets.importTemplate(":star-alignment")

wf.prepare(func(args){
	return{
		resolvedInput: wf.resolve(args.ref, { errIfMissing: true })
	}
})


wf.body(func(args) {

	blockId := wf.blockId().getDataAsJson()
	input := args.resolvedInput
	inputSpec := input.spec

	species := args.species
	strandness := args.strandness

	fileExtension := inputSpec.domain["pl7.app/fileExtension"]

	rawCountsConvertSettings := pfCountsConv.getColumns(species, blockId)

	targetOutputs := [{
		type: "Resource",
		spec: {
			kind: "PColumn",
			name: "github.com/alexdobin/STAR/log",
			domain: {
				"pl7.app/blockId": blockId
			},
			valueType: "Log"
		},
		name: "starLog"
	}, {
		type: "Resource",
		spec: {
			kind: "PColumn",
			name: "github.com/alexdobin/STAR/report",
			domain: {
				"pl7.app/blockId": blockId
			},
			valueType: "File"
		},
		name: "starReport"
	}, {
		type: "Resource",
		spec: {
			kind: "PColumn",
			name: "github.com/alexdobin/STAR/featureCounts/log",
			domain: {
				"pl7.app/blockId": blockId
			},
			valueType: "Log"
		},
		name: "featureCountsLog"
	}, {
		type: "Resource",
		spec: {
			kind: "PColumn",
			name: "github.com/alexdobin/STAR/featureCounts/report",
			domain: {
				"pl7.app/blockId": blockId
			},
			valueType: "File"
		},
		name: "countsReport"
	}, {
		type: "Xsv",
		xsvType: "tsv",
		settings: rawCountsConvertSettings,
		name: "rawCounts",
		path: ["rawCountsTsv"]
	}]

	// aggIndices := undefined
	// if len(inputSpec.axesSpec) == 1 { // Fasta
	// 	aggIndices = []
	// } else if len(inputSpec.axesSpec) == 2 { // Fastq
	// 	ll.assert(inputSpec.axesSpec[1].name == "pl7.app/sequencing/readIndex", "unexpected axis name " + inputSpec.axesSpec[1].name)
	// 	aggIndices = [1]
	// } else if len(inputSpec.axesSpec) == 3 { // MultilaneFastq
	// 	ll.assert(inputSpec.axesSpec[1].name == "pl7.app/sequencing/lane", "unexpected axis name " + inputSpec.axesSpec[1].name)
	// 	ll.assert(inputSpec.axesSpec[2].name == "pl7.app/sequencing/readIndex", "unexpected axi name " + inputSpec.axesSpec[2].name)
	// 	aggIndices = [1, 2]
	// } else {
	// 	ll.panic("unexpected structure of input PColumn with sequencing data")
	// }

	starResults := pframes.processColumn(
		{ spec: inputSpec, data: input.data }, starAlignmentTpl,
		targetOutputs,
		{
			aggregate: [{
				name: "pl7.app/sequencing/lane",
				optional: true
			}, {
				name: "pl7.app/sequencing/readIndex",
				optional: true
			}],
			// resulting aggregation axes names will be checked against supported combinations
			// in the body template
			passAggregationAxesNames: true,

			// will be automatically propagated to all output specs
			traceSteps: [{type: "milaboratories.star-read-mapping", id: blockId, importance: 20, label: "STAR - " + genomes.getSpeciesName(species)}],

			extra: {
				species: species,
				strandness: strandness,
				fileExtension: fileExtension
			}
		}
	)

	rawCountsPf := {
		"rawCounts.spec": starResults.outputSpec("rawCounts"),
		"rawCounts.data": starResults.outpuData("rawCounts")
	}

	// Convert pf to csv
	csvCounts := xsv.exportFrame(rawCountsPf, "csv", {})

	// Run clustering QC on all samples
	clusteringQC := exec.builder().
		software(assets.importSoftware("@platforma-open/milaboratories.star-read-mapping.software:run-sample-qc")).
		arg("rawCounts.csv").
		arg(".").
		addFile("rawCounts.csv", csvCounts).
		saveFile("pca_results.csv").
		saveFile("sample_distances.csv").
		printErrStreamToStdout().
		saveStdoutContent().
		cache(24 * 60 * 60 * 1000).
		run()

	PCAcsvImportParams := pfPcaConv.getColumns(blockId, inputSpec)
	PCAComponents := xsv.importFile(clusteringQC.getFile("pca_results.csv"), "csv", PCAcsvImportParams)

	HQtsvImportParams := hcPfconvParams.getColumns(blockId, inputSpec)
	// Load data matrix and transpose it converting the first axis (Sample) into
	// sample1 column, the second axis (previous columns) into sample2 columns,
	// and the distance values in the "value" column
	sampleDistances := xsv.importFile(clusteringQC.getFile("sample_distances.csv"), "csv", HQtsvImportParams,
												{transpose: {
													pAxisIdx: 0,
													pAxisNameOverride: "sample1",
													sAxisName: "sample2",
													valueName: "value"
												}})

	countNorm := exec.builder().
		software(assets.importSoftware("@platforma-open/milaboratories.star-read-mapping.software:normalize-counts")).
		arg("rawCounts.csv").arg(".").arg(species).
		addFile("rawCounts.csv", csvCounts).
		saveFile("normalized_counts.csv").
		//saveFile("lognormalized_counts.csv").
		printErrStreamToStdout().
		saveStdoutContent().
		cache(24 * 60 * 60 * 1000).
		run()

	normCountsImportParams := pfNormCountsConv.getColumns(blockId, inputSpec, species)
	normCountsPf := xsv.importFile(countNorm.getFile("normalized_counts.csv"), "csv", normCountsImportParams)
	//normCountsPfData := xsv.importFile(countNorm.getFile("normalized_counts.csv"), "csv", normCountsImportParams)

	outputs := {
		starProgress: starResults.output("starLog"),
		starQc: starResults.output("starReport"),
		featureCountsProgress: starResults.output("featureCountsLog"),
		featureCountsQc: starResults.output("countsReport"),
		rawCountsPf: pframes.exportFrame(rawCountsPf),
		pcaComponents: pframes.exportFrame(PCAComponents),
		normCountsPf: pframes.exportFrame(normCountsPf),
		sampleDistances: pframes.exportFrame(sampleDistances)
	}

	// Count matrix export defined with sample from inputSpec + previous specs
	exports := {
		rawCount : {
			spec: trace.inject({
				kind: "PColumn",
				name: "pl7.app/rna-seq/countMatrix",
				domain: {
					"pl7.app/blockId": blockId,
					"pl7.app/species": species,
					"pl7.app/rna-seq/normalized": "false"
				},
				valueType: "Double",
				annotations: {
					"pl7.app/label": "Raw gene expression"
				},
				axesSpec: [
					inputSpec.axesSpec[0],
					{
						"name": "pl7.app/rna-seq/geneId",
						"type": "String",
						"domain": {
							"pl7.app/blockId": blockId,
							"pl7.app/species": species
						},
						"annotations": {
							"pl7.app/label": "Ensembl Id"
						}
					}
					]
			}),
			data: starResults.output("rawCounts")
	 	},
	normCount : {
			spec: trace.inject({
				kind: "PColumn",
				name: "pl7.app/rna-seq/countMatrix",
				domain: {
					"pl7.app/blockId": blockId,
					"pl7.app/species": species,
					"pl7.app/rna-seq/normalized": "true"

				},
				valueType: "Double",
				annotations: {
					"pl7.app/label": "Normalized gene expression",
					"pl7.app/table/hValue": "true"
				},
				axesSpec: [
					inputSpec.axesSpec[0],
					{
						"name": "pl7.app/rna-seq/geneId",
						"type": "String",
						"domain": {
							"pl7.app/blockId": blockId,
							"pl7.app/species": species
						},
						"annotations": {
							"pl7.app/label": "Ensembl Id"
						}
					}
					]
			}),
			data: normCountsPf["normcounts.data"]
		},
	geneSymbols: {
		spec: trace.inject({
				kind: "PColumn",
				name: "geneSymbols",
				domain: {
					"pl7.app/blockId": blockId,
					"pl7.app/species": species
				},
				valueType: "String",
				annotations: {
					"pl7.app/label": "Gene Symbol"
				},
				axesSpec: [
					inputSpec.axesSpec[0],
					{
						"name": "pl7.app/rna-seq/geneId",
						"type": "String",
						"domain": {
							"pl7.app/blockId": blockId,
							"pl7.app/species": species
						},
						"annotations": {
							"pl7.app/label": "Ensembl Id",
							"pl7.app/axisNature": "scaleCompatible"//,
							// "pl7.app/table/orderPriority": "10"
						}
					}
					]
			}),
			data: normCountsPf["genesymbol.data"]
	}
	}

	return {
		outputs: outputs,
		exports: exports
	}
})
