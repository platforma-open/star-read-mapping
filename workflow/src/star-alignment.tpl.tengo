self := import("@platforma-sdk/workflow-tengo:tpl")

json := import("json")

ll := import("@platforma-sdk/workflow-tengo:ll")
xsv := import("@platforma-sdk/workflow-tengo:pframes.xsv")
exec := import("@platforma-sdk/workflow-tengo:exec")
file := import("@platforma-sdk/workflow-tengo:file")
assets := import("@platforma-sdk/workflow-tengo:assets")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
pConstants := import("@platforma-sdk/workflow-tengo:pframes.constants")

genomes := import(":genomes")

self.defineOutputs("starLog",
	"starReport",
	"featureCountsLog",
	"countsReport",
	"countMatrixImport")


self.body(func(inputs) {
	inputData := inputs[pConstants.VALUE_FIELD_NAME]
	species := inputs.species
	fileExtension := inputs.fileExtension
	strandness := inputs.strandness

	genomeAssets := genomes.getGenomeAsset(species)

	inputDataMeta := inputData.getDataAsJson()

	star:= exec.builder().
		software(assets.importSoftware("@platforma-open/milaboratories.software-star:star")).
		mkDir("genomeIndex").
		addAsset(genomeAssets, "genomeIndex", ["chrLength.txt"]).
		addAsset(genomeAssets, "genomeIndex", ["chrName.txt"]).
		addAsset(genomeAssets, "genomeIndex", ["chrNameLength.txt"]).
		addAsset(genomeAssets, "genomeIndex", ["chrStart.txt"]).
		addAsset(genomeAssets, "genomeIndex", ["exonGeTrInfo.tab"]).
		addAsset(genomeAssets, "genomeIndex", ["exonInfo.tab"]).
		addAsset(genomeAssets, "genomeIndex", ["geneInfo.tab"]).
		addAsset(genomeAssets, "genomeIndex", ["Genome"]).
		addAsset(genomeAssets, "genomeIndex", ["genomeParameters.txt"]).
		//addAsset(genomeAssets, "genomeIndex", ["Log.out"]).
		addAsset(genomeAssets, "genomeIndex", ["SA"]).
		addAsset(genomeAssets, "genomeIndex", ["SAindex"]).
		addAsset(genomeAssets, "genomeIndex", ["sjdbInfo.txt"]).
		addAsset(genomeAssets, "genomeIndex", ["sjdbList.fromGTF.out.tab"]).
		addAsset(genomeAssets, "genomeIndex", ["sjdbList.out.tab"]).
		addAsset(genomeAssets, "genomeIndex", ["transcriptInfo.tab"]).
		arg("--genomeDir").arg("genomeIndex").
		arg("--outSAMtype").arg("BAM").arg("SortedByCoordinate").
		arg("--readFilesIn")

	nReads := 0
	filesByRIndex := {}
	if inputDataMeta.keyLength == 1 {
		for sKey, inputFile in inputData.inputs() {
			key := json.decode(sKey)
			r := key[0]
			if (r[0] != 'R' && r[0] != "I") || (r[1] != '1' && r[1] != '2') || len(r) != 2 {
				ll.panic("malformed read index: %v", r)
			}
			fileName := "input_" + r + "." + fileExtension
			star.addFile(fileName, inputFile).arg(fileName)
			filesByRIndex[r] = inputFile
		}

		for rIndex in ["R1", "R2"] {
			inputFile := filesByRIndex[rIndex]
			if is_undefined(inputFile) {
				continue
			}
			nReads = nReads + 1
		}
		ll.assert(nReads != 0, "No R read indexes")
	} else if inputDataMeta.keyLength == 2 {
		fileLists := {}
		for sKey, inputFile in inputData.inputs() {
			key := json.decode(sKey)
			lane := key[0]
			r := key[1]
			if (r[0] != 'R' && r[0] != "I") || (r[1] != '1' && r[1] != '2') || len(r) != 2 {
				ll.panic("malformed read index: %v", r)
			}
			if is_undefined(int(lane)) {
				ll.panic("malformed lane: %v", lane)
			}
			fileName := "input_L" + lane + "_" + r + "." + fileExtension
			star.addFile(fileName, inputFile)

			// Initialize as an empty array if key does not exist
			if fileLists[r] == undefined {
				fileLists[r] = []
			}
    		fileLists[r] = append(fileLists[r], fileName)

			filesByRIndex[r] = inputFile
		}

		// Function to extract lane number manually
		extractLaneNumber := func(file) {
			prefix := "input_L"  // Extract number from "input_L01_R1.fastq.gz"
			start := len(prefix)  // Position after "input_L"

			numStr := ""
			for i := start; i < len(file); i++ {
				char := file[i]
				if char >= '0' && char <= '9' {
					numStr = numStr + char
				} else {
					break  // Stop when encountering a non-numeric character
				}
			}
			return int(numStr)  // Convert "01" â†’ 1
		}

		// Manual Bubble Sort
		bubbleSort := func(arr) {
			n := len(arr)
			for i := 0; i < n-1; i++ {
				for j := 0; j < n-1-i; j++ {
					if extractLaneNumber(arr[j]) > extractLaneNumber(arr[j+1]) {
						// Swap arr[j] and arr[j+1]
						temp := arr[j]
						arr[j] = arr[j+1]
						arr[j+1] = temp
					}
				}
			}
			return arr
		}

		// Sort files by lane number to ensure R1 and R2 are aligned
		sortedR1 := bubbleSort(fileLists["R1"])
		sortedR2 := bubbleSort(fileLists["R2"])


		// Function to manually join a list into a comma-separated string
		join := func(arr) {
			result := ""
			for i, el in arr {
				if i > 0 {
					result = result + ","  // Add comma separator for subsequent elements
				}
				result = result + el
			}
			return result
		}

		// Convert file lists into comma-separated strings
		r1Files := join(sortedR1)
		r2Files := join(sortedR2)
		star.arg(r1Files).arg(r2Files)

		for rIndex in ["R1", "R2"] {
			inputFile := filesByRIndex[rIndex]
			if is_undefined(inputFile) {
				continue
			}
			nReads = nReads + 1
		}
		ll.assert(nReads != 0, "No R read indexes")
	}

	if fileExtension == "fastq.gz" || fileExtension == "fq.gz" {
		star = star.arg("--readFilesCommand").arg("gunzip -c")
	}


	star = star.
		arg("--outFileNamePrefix").arg("sample_").
		arg("--runThreadN").arg("4").
		saveFile("sample_Aligned.sortedByCoord.out.bam").
		saveFile("sample_Log.final.out").
		printErrStreamToStdout().
		saveStdoutContent().
		cache(24 * 60 * 60 * 1000).
		run()


	starLog := star.getStdoutStream()
	starReport := star.getFile("sample_Log.final.out")
	bamFile := star.getFile("sample_Aligned.sortedByCoord.out.bam")

	// Calculate counts from BAM file
	featureCounts:= exec.builder().
		software(assets.importSoftware("@platforma-open/milaboratories.software-subread:featureCounts")).
		addFile("sample_Aligned.sortedByCoord.out.bam", bamFile).
		addAsset(genomeAssets, ".", ["annotations.gtf"]).
		arg("-t").arg("exon").
		arg("-g").arg("gene_id").
		arg("-s").arg(strandness).
		arg("-T").arg("4").
		arg("-a").arg("annotations.gtf")

	if nReads == 2 {
		featureCounts = featureCounts.arg("-p")
	}

	featureCounts = featureCounts.
		arg("-o").arg("rawCounts.tsv").
		arg("sample_Aligned.sortedByCoord.out.bam").
		saveFile("rawCounts.tsv").
		saveFile("rawCounts.tsv.summary"). // featureCounts qc
		printErrStreamToStdout().
		saveStdoutContent().
		cache(24 * 60 * 60 * 1000).
		run()


	featureCountsLog := featureCounts.getStdoutStream()
	countsReport := featureCounts.getFile("rawCounts.tsv.summary")
	outputFeatureCounts := featureCounts.getFile("rawCounts.tsv")

	// tsvImportParams := pfCountsConv.getColumns(species)

	// countMatrixImport := xsv.importFile(featureCounts.getFile("rawCounts.tsv"), "tsv", tsvImportParams, { dataOnly: true })

	rawCountsTsv := featureCounts.getFile("rawCounts.tsv")

	// PFrame
	//   rawCounts.data
	//   rawCounts.spec
	// after we add { dataOnly: true }
	//   rawCounts [ containing value from rawCounts.data ]
	ll.print("print import params", tsvImportParams)

	output := {
		starLog: starLog,
		starReport: file.exportFile(starReport),
		featureCountsLog: featureCountsLog,
		countsReport: file.exportFile(countsReport),
		rawCountsTsv: rawCountsTsv
	}

	return output

})
